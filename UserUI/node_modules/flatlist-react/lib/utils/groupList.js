"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var isType_1 = require("./isType");
var getObjectDeepKeyValue_1 = __importDefault(require("./getObjectDeepKeyValue"));
var defaultGroupOptions = {
    by: '',
    limit: 0,
    reversed: false
};
var handleGroupReverse = function (groupedLists, reverse) {
    if (reverse === void 0) { reverse = false; }
    if (reverse && isType_1.isBoolean(reverse)) {
        return groupedLists.map(function (group) { return group.reverse(); });
    }
    return groupedLists;
};
var groupList = function (list, options) {
    if (options === void 0) { options = defaultGroupOptions; }
    var groupLabels = [];
    if (!isType_1.isObject(options) || Object.keys(options).length === 0) {
        options = defaultGroupOptions;
    }
    var groupBy = options.by, limit = options.limit;
    if (groupBy && (isType_1.isFunction(groupBy) || isType_1.isString(groupBy))) {
        var groupedList = list
            .reduce(function (prevList, item, idx) {
            var groupLabel = isType_1.isFunction(groupBy)
                ? groupBy(item, idx)
                : getObjectDeepKeyValue_1.default(groupBy, item);
            if (!prevList[groupLabel]) {
                prevList[groupLabel] = [];
            }
            if (!limit || (limit > 0 && prevList[groupLabel].length < limit)) {
                prevList[groupLabel].push(item);
            }
            return prevList;
        }, {});
        // using Set here so the order is preserved and prevent duplicates
        groupLabels = Array.from(new Set(Object.keys(groupedList)));
        return { groupLabels: groupLabels, groupLists: handleGroupReverse(Object.values(groupedList), options.reversed) };
    }
    if (limit && isType_1.isNumber(limit) && (limit > 0)) {
        var groupLists = list.reduce(function (groupedList, item, idx) {
            groupedList[groupedList.length - 1].push(item);
            var itemNumber = idx + 1;
            if (itemNumber < list.length // make sure separator is not added at the end
                && (itemNumber % (limit || 0)) === 0) {
                groupedList.push([]);
            }
            return groupedList;
        }, [[]]);
        groupLabels = Array(groupLists.length).fill(0).map(function (x, i) { return (i + 1); });
        return { groupLabels: groupLabels, groupLists: handleGroupReverse(groupLists, options.reversed) };
    }
    return { groupLabels: groupLabels, groupLists: handleGroupReverse([list], options.reversed) };
};
exports.default = groupList;
//# sourceMappingURL=groupList.js.map