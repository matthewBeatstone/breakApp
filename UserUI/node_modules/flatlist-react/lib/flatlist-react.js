"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(require("react"));
var prop_types_1 = require("prop-types");
var filterList_1 = __importDefault(require("./utils/filterList"));
var sortList_1 = __importDefault(require("./utils/sortList"));
var searchList_1 = __importDefault(require("./utils/searchList"));
var groupList_1 = __importDefault(require("./utils/groupList"));
var isType_1 = require("./utils/isType");
var convertListToArray_1 = __importDefault(require("./utils/convertListToArray"));
var limitList_1 = __importDefault(require("./utils/limitList"));
var DefaultBlank_1 = __importDefault(require("./subComponents/DefaultBlank"));
var DisplayHandler_1 = __importDefault(require("./subComponents/DisplayHandler"));
var InfiniteLoader_1 = __importDefault(require("./subComponents/InfiniteLoader"));
var FlatList = react_1.forwardRef(function (props, ref) {
    var renderItem = props.renderItem, limit = props.limit, reversed = props.reversed, renderWhenEmpty = props.renderWhenEmpty, wrapperHtmlTag = props.wrapperHtmlTag, filterBy = props.filterBy, groupBy = props.groupBy, groupSeparator = props.groupSeparator, groupOf = props.groupOf, showGroupSeparatorAtTheBottom = props.showGroupSeparatorAtTheBottom, groupReversed = props.groupReversed, sortBy = props.sortBy, sortDesc = props.sortDesc, sort = props.sort, sortCaseInsensitive = props.sortCaseInsensitive, sortGroupBy = props.sortGroupBy, sortGroupDesc = props.sortGroupDesc, searchBy = props.searchBy, searchOnEveryWord = props.searchOnEveryWord, searchTerm = props.searchTerm, searchCaseInsensitive = props.searchCaseInsensitive, display = props.display, displayRow = props.displayRow, rowGap = props.rowGap, displayGrid = props.displayGrid, gridGap = props.gridGap, minColumnWidth = props.minColumnWidth, hasMoreItems = props.hasMoreItems, loadMoreItems = props.loadMoreItems, paginationLoadingIndicator = props.paginationLoadingIndicator, paginationLoadingIndicatorPosition = props.paginationLoadingIndicatorPosition, otherProps = __rest(props, ["renderItem", "limit", "reversed", "renderWhenEmpty", "wrapperHtmlTag", "filterBy", "groupBy", "groupSeparator", "groupOf", "showGroupSeparatorAtTheBottom", "groupReversed", "sortBy", "sortDesc", "sort", "sortCaseInsensitive", "sortGroupBy", "sortGroupDesc", "searchBy", "searchOnEveryWord", "searchTerm", "searchCaseInsensitive", "display", "displayRow", "rowGap", "displayGrid", "gridGap", "minColumnWidth", "hasMoreItems", "loadMoreItems", "paginationLoadingIndicator", "paginationLoadingIndicatorPosition"]);
    var list = otherProps.list, group = otherProps.group, search = otherProps.search, pagination = otherProps.pagination, tagProps = __rest(otherProps, ["list", "group", "search", "pagination"]);
    list = convertListToArray_1.default(list);
    var renderBlank = function () {
        return (renderWhenEmpty && isType_1.isFunction(renderWhenEmpty) ? renderWhenEmpty() : DefaultBlank_1.default);
    };
    if (list.length === 0) {
        return renderBlank();
    }
    var renderList = list.slice();
    if (reversed) {
        renderList = renderList.reverse();
    }
    if (limit !== null) {
        renderList = limitList_1.default(renderList, limit);
    }
    var handleRenderItem = function (item, key) {
        if (isType_1.isFunction(renderItem)) {
            return renderItem(item, key);
        }
        var comp = renderItem;
        return (react_1.default.createElement(comp.type, __assign({}, comp.props, { key: key, item: item })));
    };
    var renderGroupedList = function () {
        group = __assign({}, (FlatList.defaultProps && FlatList.defaultProps.group), group);
        var groupingOptions = {
            by: group.by || groupBy,
            limit: group.limit || groupOf,
            reversed: group.reversed || groupReversed
        };
        var _a = groupList_1.default(renderList, groupingOptions), groupLists = _a.groupLists, groupLabels = _a.groupLabels;
        return groupLists
            .reduce(function (groupedList, aGroup, idx) {
            var customSeparator = group.separator || groupSeparator;
            var separatorKey = "separator-" + idx;
            var separator = (react_1.default.createElement("hr", { key: separatorKey, className: '___list-separator' }));
            if (customSeparator) {
                if (isType_1.isFunction(customSeparator)) {
                    separator = customSeparator(aGroup, idx, groupLabels[idx]);
                }
                else {
                    separator = customSeparator;
                }
                separator = (react_1.default.createElement(separator.type, __assign({}, separator.props, { key: separatorKey, className: ((separator.props.className || '') + " ___list-separator").trim() })));
            }
            if (group.sortBy || sortGroupBy || sort.groupBy) {
                aGroup = sortList_1.default(aGroup, {
                    caseInsensitive: group.sortCaseInsensitive ||
                        sortCaseInsensitive || sort.groupCaseInsensitive,
                    descending: group.sortDescending ||
                        sortGroupDesc || sort.groupDescending,
                    onKey: group.sortBy || sortGroupBy || sort.groupBy
                });
            }
            var groupedItems = aGroup
                .map(function (item, i) { return handleRenderItem(item, idx + "-" + i); });
            if (group.separatorAtTheBottom || showGroupSeparatorAtTheBottom) {
                return groupedList.concat.apply(groupedList, groupedItems.concat([separator]));
            }
            return groupedList.concat.apply(groupedList, [separator].concat(groupedItems));
        }, []);
    };
    if (filterBy) {
        renderList = filterList_1.default(renderList, filterBy);
    }
    if ((searchTerm && searchBy) || (search.term && search.by)) {
        search = __assign({}, (FlatList.defaultProps && FlatList.defaultProps.search), search);
        renderList = searchList_1.default(renderList, {
            by: search.by || searchBy,
            caseInsensitive: search.caseInsensitive || searchCaseInsensitive,
            everyWord: search.everyWord || searchOnEveryWord,
            term: search.term || searchTerm
        });
    }
    var _a = sort, caseInsensitive = _a.caseInsensitive, by = _a.by, descending = _a.descending;
    if (by || sortBy || (isType_1.isBoolean(sort) && sort)) {
        renderList = sortList_1.default(renderList, {
            caseInsensitive: caseInsensitive || sortCaseInsensitive,
            descending: descending || sortDesc,
            onKey: by || sortBy
        });
    }
    if (pagination && pagination.loadMore) {
        pagination = __assign({}, (FlatList.defaultProps && FlatList.defaultProps.pagination), pagination);
    }
    var content = (react_1.default.createElement(react_1.Fragment, null,
        renderList.length > 0 ?
            (group.by || group.limit || groupBy || groupOf) ?
                renderGroupedList() :
                renderList.map(handleRenderItem) :
            renderBlank(),
        react_1.default.createElement(DisplayHandler_1.default, __assign({}, { display: display, displayRow: displayRow, rowGap: rowGap, displayGrid: displayGrid, gridGap: gridGap, minColumnWidth: minColumnWidth }, { showGroupSeparatorAtTheBottom: group.separatorAtTheBottom || showGroupSeparatorAtTheBottom })),
        (loadMoreItems || (pagination && pagination.loadMore)) &&
            react_1.default.createElement(InfiniteLoader_1.default, { hasMore: hasMoreItems || pagination.hasMore, loadMore: loadMoreItems || pagination.loadMore, loadingIndicator: paginationLoadingIndicator || pagination.loadingIndicator, loadingIndicatorPosition: paginationLoadingIndicatorPosition || pagination.loadingIndicatorPosition })));
    var WrapperElement = "" + wrapperHtmlTag;
    return (react_1.default.createElement(react_1.Fragment, null, WrapperElement ?
        react_1.default.createElement(WrapperElement, __assign({ ref: ref }, tagProps), content) :
        content));
});
FlatList.propTypes = {
    display: prop_types_1.shape({
        grid: prop_types_1.bool,
        gridColumnWidth: prop_types_1.string,
        gridGap: prop_types_1.string,
        row: prop_types_1.bool,
        rowGap: prop_types_1.string,
    }),
    displayGrid: prop_types_1.bool,
    displayRow: prop_types_1.bool,
    filterBy: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
    gridGap: prop_types_1.string,
    group: prop_types_1.shape({
        by: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
        limit: prop_types_1.number,
        reversed: prop_types_1.bool,
        separator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
        separatorAtTheBottom: prop_types_1.bool,
        sortBy: prop_types_1.string,
        sortCaseInsensitive: prop_types_1.bool,
        sortDescending: prop_types_1.bool,
    }),
    groupBy: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
    groupOf: prop_types_1.number,
    groupReversed: prop_types_1.bool,
    groupSeparator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
    hasMoreItems: prop_types_1.bool,
    limit: prop_types_1.number,
    list: prop_types_1.oneOfType([prop_types_1.array, prop_types_1.object]).isRequired,
    loadMoreItems: prop_types_1.func,
    minColumnWidth: prop_types_1.string,
    pagination: prop_types_1.shape({
        hasMore: prop_types_1.bool,
        loadMore: prop_types_1.func,
        loadingIndicator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
        loadingIndicatorPosition: prop_types_1.string,
    }),
    paginationLoadingIndicator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
    paginationLoadingIndicatorPosition: prop_types_1.oneOf(['left', 'center', 'right', '']),
    renderItem: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.node]).isRequired,
    renderWhenEmpty: prop_types_1.func,
    reversed: prop_types_1.bool,
    rowGap: prop_types_1.string,
    search: prop_types_1.shape({
        by: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
        caseInsensitive: prop_types_1.bool,
        everyWord: prop_types_1.bool,
        term: prop_types_1.string
    }),
    searchBy: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
    searchCaseInsensitive: prop_types_1.bool,
    searchOnEveryWord: prop_types_1.bool,
    searchTerm: prop_types_1.string,
    showGroupSeparatorAtTheBottom: prop_types_1.bool,
    sort: prop_types_1.oneOfType([prop_types_1.bool, prop_types_1.shape({
            by: prop_types_1.string,
            caseInsensitive: prop_types_1.bool,
            descending: prop_types_1.bool,
            groupBy: prop_types_1.string,
            groupCaseInsensitive: prop_types_1.bool,
            groupDescending: prop_types_1.bool,
        })]),
    sortBy: prop_types_1.string,
    sortDesc: prop_types_1.bool,
    sortGroupBy: prop_types_1.string,
    sortGroupDesc: prop_types_1.bool,
    wrapperHtmlTag: prop_types_1.string
};
FlatList.defaultProps = {
    display: {
        grid: false,
        gridGap: '',
        gridMinColumnWidth: '',
        row: false,
        rowGap: '',
    },
    displayGrid: false,
    displayRow: false,
    filterBy: '',
    gridGap: '',
    group: {
        by: '',
        limit: 0,
        reversed: false,
        separator: null,
        separatorAtTheBottom: false,
        sortBy: '',
        sortCaseInsensitive: false,
        sortDescending: false,
    },
    groupBy: '',
    groupOf: 0,
    groupReversed: false,
    groupSeparator: null,
    hasMoreItems: false,
    limit: 0,
    loadMoreItems: null,
    minColumnWidth: '',
    pagination: {
        hasMore: false,
        loadMore: null,
        loadingIndicator: null,
        loadingIndicatorPosition: '',
    },
    paginationLoadingIndicator: undefined,
    paginationLoadingIndicatorPosition: '',
    renderWhenEmpty: null,
    reversed: false,
    rowGap: '',
    search: {
        by: '',
        caseInsensitive: false,
        everyWord: false,
        term: ''
    },
    searchBy: '',
    searchCaseInsensitive: false,
    searchOnEveryWord: false,
    searchTerm: '',
    showGroupSeparatorAtTheBottom: false,
    sort: false,
    sortBy: '',
    sortCaseInsensitive: false,
    sortDesc: false,
    sortGroupBy: '',
    sortGroupDesc: false,
    wrapperHtmlTag: '',
};
exports.default = react_1.memo(FlatList);
//# sourceMappingURL=flatlist-react.js.map