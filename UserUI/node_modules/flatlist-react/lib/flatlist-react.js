"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var prop_types_1 = require("prop-types");
var react_1 = __importStar(require("react"));
var DefaultBlank_1 = __importDefault(require("./subComponents/DefaultBlank"));
var DisplayHandler_1 = __importDefault(require("./subComponents/DisplayHandler"));
var InfiniteLoader_1 = __importDefault(require("./subComponents/InfiniteLoader"));
var convertListToArray_1 = __importDefault(require("./utils/convertListToArray"));
var filterList_1 = __importDefault(require("./utils/filterList"));
var groupList_1 = __importDefault(require("./utils/groupList"));
var isType_1 = require("./utils/isType");
var limitList_1 = __importDefault(require("./utils/limitList"));
var searchList_1 = __importDefault(require("./utils/searchList"));
var sortList_1 = __importDefault(require("./utils/sortList"));
var propTypes = {
    /**
     * display shorthand configuration
     */
    display: prop_types_1.shape({
        grid: prop_types_1.bool,
        gridColumnWidth: prop_types_1.string,
        gridGap: prop_types_1.string,
        row: prop_types_1.bool,
        rowGap: prop_types_1.string
    }),
    /**
     * activate display grid on the items container
     */
    displayGrid: prop_types_1.bool,
    /**
     * activate display block on items and items container
     */
    displayRow: prop_types_1.bool,
    /**
     * a string representing a key on the object or a function takes the item and its index that returns
     * true or false whether to include the item or not
     */
    filterBy: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
    /**
     * the spacing in between columns and rows. Similar to CSS grid-gap
     */
    gridGap: prop_types_1.string,
    /**
     * a group shorthand configuration
     */
    group: prop_types_1.shape({
        by: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
        limit: prop_types_1.number,
        reversed: prop_types_1.bool,
        separator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
        separatorAtTheBottom: prop_types_1.bool,
        sortBy: prop_types_1.string,
        sortCaseInsensitive: prop_types_1.bool,
        sortDescending: prop_types_1.bool
    }),
    /**
     * a string representing a key on the object or a function takes the item and its index that returns
     * true or false whether to include the item or not
     */
    groupBy: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
    /**
     * the size of the groups to be created
     */
    groupOf: prop_types_1.number,
    /**
     * a flag to read groups backwards(in reverse)
     */
    groupReversed: prop_types_1.bool,
    /**
     * a component or a function that returns a component to be rendered in between groups
     */
    groupSeparator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
    /**
     * a flag to indicate whether there are more items to the list that can be loaded
     */
    hasMoreItems: prop_types_1.bool,
    /**
     * the number representing the max number of items to display
     */
    limit: prop_types_1.number,
    /**
     * a list of anything to be displayed
     */
    list: prop_types_1.oneOfType([prop_types_1.array, prop_types_1.object]).isRequired,
    /**
     * a function to be called when list has been scrolled to the end
     */
    loadMoreItems: prop_types_1.func,
    /**
     * the minimum column width when display grid is activated
     */
    minColumnWidth: prop_types_1.string,
    /**
     * a pagination shorthand configuration
     */
    pagination: prop_types_1.shape({
        hasMore: prop_types_1.bool,
        loadMore: prop_types_1.func,
        loadingIndicator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
        loadingIndicatorPosition: prop_types_1.string
    }),
    /**
     * a custom element to be used instead of the default loading indicator for pagination
     */
    paginationLoadingIndicator: prop_types_1.oneOfType([prop_types_1.node, prop_types_1.func, prop_types_1.element]),
    /**
     * the position of the custom loader indicator
     */
    paginationLoadingIndicatorPosition: prop_types_1.oneOf(['left', 'center', 'right', '']),
    /**
     * a jsx element or a function that it is called for every item on the list and returns a jsx element
     */
    renderItem: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.node]).isRequired,
    /**
     * the function that gets called when the list is empty or was filtered to the point it became empty
     */
    renderWhenEmpty: prop_types_1.func,
    /**
     * a flag to read the given list backwards(in reverse)
     */
    reversed: prop_types_1.bool,
    /**
     * the spacing in between rows when display row is activated
     */
    rowGap: prop_types_1.string,
    /**
     * a search shorthand configuration
     */
    search: prop_types_1.shape({
        by: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
        caseInsensitive: prop_types_1.bool,
        everyWord: prop_types_1.bool,
        term: prop_types_1.string
    }),
    /**
     * a string representing a key on the object or a function takes the item and its index that returns
     * true or false whether to include the item or not
     */
    searchBy: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.string]),
    /**
     * a flag that indicates whether to make search case insensitive or not
     */
    searchCaseInsensitive: prop_types_1.bool,
    /**
     * a flag that indicates how the search should be done. By default is set to True
     */
    searchOnEveryWord: prop_types_1.bool,
    /**
     * a string representing the term to match when doing search or that will be passed to searchBy function
     */
    searchTerm: prop_types_1.string,
    /**
     * a flag to indicate whether the separator should be on the bottom or not
     */
    showGroupSeparatorAtTheBottom: prop_types_1.bool,
    /**
     * a flag to indicate that the list should be sorted (uses default sort configuration)
     */
    sort: prop_types_1.oneOfType([prop_types_1.bool, prop_types_1.shape({
            by: prop_types_1.string,
            caseInsensitive: prop_types_1.bool,
            descending: prop_types_1.bool,
            groupBy: prop_types_1.string,
            groupCaseInsensitive: prop_types_1.bool,
            groupDescending: prop_types_1.bool
        })]),
    /**
     * a string representing a key in the item that should be used to sort the list
     */
    sortBy: prop_types_1.string,
    /**
     * a flag to indicate that sort should be done in descending order
     */
    sortDesc: prop_types_1.bool,
    /**
     * a string representing a key in the item that should be used to sort the list groups
     */
    sortGroupBy: prop_types_1.string,
    /**
     * a flag to indicate that sort should be done in descending order inside each group
     */
    sortGroupDesc: prop_types_1.bool,
    /**
     * a optional html tag to use to wrap the list items
     */
    wrapperHtmlTag: prop_types_1.string
};
var defaultProps = {
    display: {
        grid: false,
        gridGap: '',
        gridMinColumnWidth: '',
        row: false,
        rowGap: ''
    },
    displayGrid: false,
    displayRow: false,
    filterBy: '',
    gridGap: '',
    group: {
        by: '',
        limit: 0,
        reversed: false,
        separator: null,
        separatorAtTheBottom: false,
        sortBy: '',
        sortCaseInsensitive: false,
        sortDescending: false
    },
    groupBy: '',
    groupOf: 0,
    groupReversed: false,
    groupSeparator: null,
    hasMoreItems: false,
    limit: 0,
    loadMoreItems: null,
    minColumnWidth: '',
    pagination: {
        hasMore: false,
        loadMore: null,
        loadingIndicator: null,
        loadingIndicatorPosition: ''
    },
    paginationLoadingIndicator: undefined,
    paginationLoadingIndicatorPosition: '',
    renderWhenEmpty: null,
    reversed: false,
    rowGap: '',
    search: {
        by: '',
        caseInsensitive: false,
        everyWord: false,
        term: ''
    },
    searchBy: '',
    searchCaseInsensitive: false,
    searchOnEveryWord: false,
    searchTerm: '',
    showGroupSeparatorAtTheBottom: false,
    sort: false,
    sortBy: '',
    sortCaseInsensitive: false,
    sortDesc: false,
    sortGroupBy: '',
    sortGroupDesc: false,
    wrapperHtmlTag: ''
};
var handleRenderItem = function (renderItem) { return function (item, key) {
    if (isType_1.isFunction(renderItem)) {
        return renderItem(item, key);
    }
    var comp = renderItem;
    return (react_1.default.createElement(comp.type, __assign({}, comp.props, { key: key, item: item })));
}; };
var renderBlank = function (renderWhenEmpty) { return (renderWhenEmpty && isType_1.isFunction(renderWhenEmpty) ? renderWhenEmpty() : DefaultBlank_1.default); };
var renderGroupedList = function (list, renderItem, _a) {
    var group = _a.group, groupBy = _a.groupBy, groupOf = _a.groupOf, groupReversed = _a.groupReversed, groupSeparator = _a.groupSeparator, sortGroupBy = _a.sortGroupBy, sort = _a.sort, sortCaseInsensitive = _a.sortCaseInsensitive, showGroupSeparatorAtTheBottom = _a.showGroupSeparatorAtTheBottom, sortGroupDesc = _a.sortGroupDesc;
    // make sure group always has the defaults
    group = __assign(__assign({}, defaultProps.group), group);
    var groupingOptions = {
        by: group.by || groupBy,
        limit: group.limit || groupOf,
        reversed: group.reversed || groupReversed
    };
    var _b = groupList_1.default(list, groupingOptions), groupLists = _b.groupLists, groupLabels = _b.groupLabels;
    return groupLists
        .reduce(function (groupedList, aGroup, idx) {
        var customSeparator = group.separator || groupSeparator;
        var separatorKey = "separator-" + idx;
        var separator = (react_1.default.createElement("hr", { key: separatorKey, className: "___list-separator" }));
        if (customSeparator) {
            if (isType_1.isFunction(customSeparator)) {
                separator = customSeparator(aGroup, idx, groupLabels[idx]);
            }
            else {
                separator = customSeparator;
            }
            separator = (react_1.default.createElement(separator.type, __assign({}, separator.props, { key: separatorKey, className: ((separator.props.className || '') + " ___list-separator").trim() })));
        }
        if (group.sortBy || sortGroupBy || sort.groupBy) {
            aGroup = sortList_1.default(aGroup, {
                caseInsensitive: group.sortCaseInsensitive
                    || sortCaseInsensitive || sort.groupCaseInsensitive,
                descending: group.sortDescending
                    || sortGroupDesc || sort.groupDescending,
                onKey: group.sortBy || sortGroupBy || sort.groupBy
            });
        }
        var groupedItems = aGroup
            .map(function (item, i) { return renderItem(item, idx + "-" + i); });
        if (group.separatorAtTheBottom || showGroupSeparatorAtTheBottom) {
            return groupedList.concat.apply(groupedList, __spreadArrays(groupedItems, [separator]));
        }
        return groupedList.concat.apply(groupedList, __spreadArrays([separator], groupedItems));
    }, []);
};
var FlatList = react_1.forwardRef(function (props, ref) {
    var list = props.list, limit = props.limit, reversed = props.reversed, renderWhenEmpty = props.renderWhenEmpty, wrapperHtmlTag = props.wrapperHtmlTag, renderItem = props.renderItem, // render/list related props
    filterBy = props.filterBy, // filter props
    group = props.group, groupBy = props.groupBy, groupSeparator = props.groupSeparator, groupOf = props.groupOf, showGroupSeparatorAtTheBottom = props.showGroupSeparatorAtTheBottom, groupReversed = props.groupReversed, // group props
    sortBy = props.sortBy, sortDesc = props.sortDesc, sort = props.sort, sortCaseInsensitive = props.sortCaseInsensitive, sortGroupBy = props.sortGroupBy, sortGroupDesc = props.sortGroupDesc, // sort props
    search = props.search, searchBy = props.searchBy, searchOnEveryWord = props.searchOnEveryWord, searchTerm = props.searchTerm, searchCaseInsensitive = props.searchCaseInsensitive, // search props
    display = props.display, displayRow = props.displayRow, rowGap = props.rowGap, displayGrid = props.displayGrid, gridGap = props.gridGap, minColumnWidth = props.minColumnWidth, // display props,
    hasMoreItems = props.hasMoreItems, loadMoreItems = props.loadMoreItems, paginationLoadingIndicator = props.paginationLoadingIndicator, paginationLoadingIndicatorPosition = props.paginationLoadingIndicatorPosition, pagination = props.pagination, // pagination props
    tagProps = __rest(props, ["list", "limit", "reversed", "renderWhenEmpty", "wrapperHtmlTag", "renderItem", "filterBy", "group", "groupBy", "groupSeparator", "groupOf", "showGroupSeparatorAtTheBottom", "groupReversed", "sortBy", "sortDesc", "sort", "sortCaseInsensitive", "sortGroupBy", "sortGroupDesc", "search", "searchBy", "searchOnEveryWord", "searchTerm", "searchCaseInsensitive", "display", "displayRow", "rowGap", "displayGrid", "gridGap", "minColumnWidth", "hasMoreItems", "loadMoreItems", "paginationLoadingIndicator", "paginationLoadingIndicatorPosition", "pagination"]) // props to be added to the wrapper container if wrapperHtmlTag is specified
    ;
    var renderList = convertListToArray_1.default(list);
    if (renderList.length === 0) {
        return renderBlank(renderWhenEmpty);
    }
    var renderThisItem = handleRenderItem(renderItem);
    if (reversed) {
        renderList = renderList.reverse();
    }
    if (limit !== null) {
        renderList = limitList_1.default(renderList, limit);
    }
    if (filterBy) {
        renderList = filterList_1.default(renderList, filterBy);
    }
    if ((searchTerm && searchBy) || (search.term && search.by)) {
        // make sure search always has the defaults
        var searchWithDefaults = __assign(__assign({}, (FlatList.defaultProps && FlatList.defaultProps.search)), search);
        renderList = searchList_1.default(renderList, {
            by: searchWithDefaults.by || searchBy,
            caseInsensitive: searchWithDefaults.caseInsensitive || searchCaseInsensitive,
            everyWord: searchWithDefaults.everyWord || searchOnEveryWord,
            term: searchWithDefaults.term || searchTerm
        });
    }
    if (sort.by || sortBy || (isType_1.isBoolean(sort) && sort)) {
        renderList = sortList_1.default(renderList, {
            caseInsensitive: sort.caseInsensitive || sortCaseInsensitive,
            descending: sort.descending || sortDesc,
            onKey: sort.by || sortBy
        });
    }
    var content = (react_1.default.createElement(react_1.default.Fragment, null,
        renderList.length > 0
            ? (group.by || group.limit || groupBy || groupOf)
                ? renderGroupedList(renderList, renderThisItem, props)
                : renderList.map(renderThisItem)
            : renderBlank(renderWhenEmpty),
        react_1.default.createElement(DisplayHandler_1.default, __assign({}, { display: display, displayRow: displayRow, rowGap: rowGap, displayGrid: displayGrid, gridGap: gridGap, minColumnWidth: minColumnWidth }, { showGroupSeparatorAtTheBottom: group.separatorAtTheBottom || showGroupSeparatorAtTheBottom })),
        (loadMoreItems || pagination.loadMore)
            && (react_1.default.createElement(InfiniteLoader_1.default, { hasMore: hasMoreItems || pagination.hasMore, loadMore: loadMoreItems || pagination.loadMore, loadingIndicator: paginationLoadingIndicator || pagination.loadingIndicator, loadingIndicatorPosition: paginationLoadingIndicatorPosition || pagination.loadingIndicatorPosition }))));
    var WrapperElement = "" + wrapperHtmlTag;
    return (react_1.default.createElement(react_1.default.Fragment, null, WrapperElement
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        ? react_1.default.createElement(WrapperElement, __assign({ ref: ref }, tagProps), content)
        : content));
});
FlatList.propTypes = propTypes;
FlatList.defaultProps = defaultProps;
exports.default = react_1.memo(FlatList);
//# sourceMappingURL=flatlist-react.js.map